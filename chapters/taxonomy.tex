\chapter{Taxonomy of Task-Based Languages}
\label{chap:taxonomy}

This chapter introduces the taxonomy of the languages and the criterion deduced from the usage of the different languages.

\section{Taxonomy}

\subsection{Task Capabilities}

\subsubsection{Architecture}
This represent which kind of architecture is addressed by the considered programming model.
With this property, we focus on \textit{shared memory} and \textit{distributed memory} architectures.
\begin{table}[H]
	\caption{Architecture}
	\centering
	\begin{multicols}{2}
		\input{chapters/taxonomy/_table_taxo_Architecture_p1.tex}

		\input{chapters/taxonomy/_table_taxo_Architecture_p2.tex}
	\end{multicols}
\end{table}


\subsubsection{Heterogeneity}
It indicates if the programming model supports accelerators (for instance, GPUs).
\textit{Explicit} support means that the user has to provide the implementation of the task that will be run on the accelerator.
\textit{Implicit} support means that the tasks can be run on different devices while the user has to provide only one implementation.
\begin{table}[H]
	\caption{Heterogeneity}
	\centering
	\begin{multicols}{2}
		\input{chapters/taxonomy/_table_taxo_Heterogeneity_p1.tex}

		\input{chapters/taxonomy/_table_taxo_Heterogeneity_p2.tex}
	\end{multicols}
\end{table}

\subsubsection{Task Granularity}
This represents the level of complexity of the task.
The tasks can be run as a single \textit{thread} or process without multi-threading.
They can also use multiple threads or processes up to one \textit{node} like OpenMP or MPI on shared memory.
Another option can be \textit{multi-node} where distributed memory technologies are used inside a task like PGAS or MPI on several nodes.
\begin{table}[H]
	\caption{Task Granularity}
	\centering
	\begin{multicols}{2}
		\input{"chapters/taxonomy/_table_taxo_Task Granularity_p1.tex"}

		\input{"chapters/taxonomy/_table_taxo_Task Granularity_p2.tex"}
	\end{multicols}
\end{table}

\subsubsection{Data Handling}
Whether the data can be accessed \textit{directly} in the task or the user has to request them from a \textit{container}.
For instance, the data can be retrieved through a future.
\begin{table}[H]
	\caption{Data Handling}
	\centering
	\begin{multicols}{2}
		\input{"chapters/taxonomy/_table_taxo_Data Handling_p1.tex"}

		\input{"chapters/taxonomy/_table_taxo_Data Handling_p2.tex"}
	\end{multicols}
\end{table}

\subsubsection{Task Implementation}
This indicates what kind of interface the user has to fill in to create a task which will be executed by the runtime of the programming model.
The tasks can use a \textit{program} where the user has to provide the parameters through the API.
It can also use a \textit{function pointer} which the user has to pass to the API as well as its parameters.
The programing paradigm can also be based on \textit{pragmas} which are used to delimit and describe the task.
Another possibility is a custom interface like a \textit{function with specific parameters} or a \textit{custom syntax}.
\begin{table}[H]
	\caption{Task Implementation}
	\centering
	\begin{multicols}{2}
		\input{"chapters/taxonomy/_table_taxo_Implementation Type_p1.tex"}

		\input{"chapters/taxonomy/_table_taxo_Implementation Type_p2.tex"}
	\end{multicols}
\end{table}

\subsubsection{Portability Accelerators}
Whether the programming model is able to support multiple accelerators architectures.
\begin{table}[H]
	\caption{Portability Accelerators}
	\centering
	\begin{multicols}{2}
		\input{"chapters/taxonomy/_table_taxo_Portability Accelerators_p1.tex"}

		\input{"chapters/taxonomy/_table_taxo_Portability Accelerators_p2.tex"}
	\end{multicols}
\end{table}

\subsection{Task and Data Management}
\subsubsection{Dependency Type}
Whether \textit{data} or \textit{control} dependencies are provided by the user.
It can be \textit{both}.
\begin{table}[H]
	\caption{Dependency Type}
	\centering
	\begin{multicols}{2}
		\input{"chapters/taxonomy/_table_taxo_Dependency Type_p1.tex"}

		\input{"chapters/taxonomy/_table_taxo_Dependency Type_p2.tex"}
	\end{multicols}
\end{table}

\subsubsection{Worker Management}
Whether the worker thread or process which hosts the tasks has to be started and maintained by the user (\textit{explicit}) or is provided by the runtime (\textit{implicit}).
\begin{table}[H]
	\caption{Worker Management}
	\centering
	\begin{multicols}{2}
		\input{"chapters/taxonomy/_table_taxo_Worker Management_p1.tex"}

		\input{"chapters/taxonomy/_table_taxo_Worker Management_p2.tex"}
	\end{multicols}
\end{table}

\subsubsection{Interoperability}
Whether it can be integrated (\textit{callee}) into another language, can call other languages (\textit{caller}) or \textit{both}.
\begin{table}[H]
	\caption{Interoperability}
	\centering
	\begin{multicols}{2}
		\input{"chapters/taxonomy/_table_taxo_Interoperability_p1.tex"}

		\input{"chapters/taxonomy/_table_taxo_Interoperability_p2.tex"}
	\end{multicols}
\end{table}

\subsubsection{Data Distribution}
How the data distribution is handled in the programming model.
\textit{Implicit} data distribution means that the runtime system decides where to place the data on the nodes whereas \textit{explicit} data distribution means that the user has to specify the distribution of the data across the nodes.
\begin{table}[H]
	\caption{Data Distribution}
	\centering
	\begin{multicols}{2}
		\input{"chapters/taxonomy/_table_taxo_Data Distribution_p1.tex"}

		\input{"chapters/taxonomy/_table_taxo_Data Distribution_p2.tex"}
	\end{multicols}
\end{table}

\subsubsection{Task Binding}
How the tasks are bind to the allocated hardware resources.
The binding can be \textit{implicit} when the runtime does it or \textit{explicit} when the user has to provide the binding.
\begin{table}[H]
	\caption{Task Binding}
	\centering
	\begin{multicols}{2}
		\input{"chapters/taxonomy/_table_taxo_Task Binding_p1.tex"}

		\input{"chapters/taxonomy/_table_taxo_Task Binding_p2.tex"}
	\end{multicols}
\end{table}

\subsubsection{Task Insertion}
Whether new tasks can be added to the task pool during the execution of the already scheduled tasks.
\begin{table}[H]
	\caption{Task Insertion}
	\centering
	\begin{multicols}{2}
		\input{"chapters/taxonomy/_table_taxo_Task Insertion_p1.tex"}

		\input{"chapters/taxonomy/_table_taxo_Task Insertion_p2.tex"}
	\end{multicols}
\end{table}

\subsection{Programming Model Features}
\subsubsection{Dependency Expression}
This feature describes how the dependencies between the tasks are represented in the considered model.
The possibilities include a \textit{graph}, a \textit{directed acyclic graph} or DAG, a \textit{tree} and a \textit{Petri Net}.
\begin{table}[H]
	\caption{Dependency Expression}
	\centering
	\begin{multicols}{2}
		\input{"chapters/taxonomy/_table_taxo_Dependency Expression_p1.tex"}

		\input{"chapters/taxonomy/_table_taxo_Dependency Expression_p2.tex"}
	\end{multicols}
\end{table}


\subsubsection{Communication Model}
How data are sent from a task to another.
The runtime system can use \textit{message passing} (msg), \textit{global address space} (gas) or the \textit{file system} (fs).
\begin{table}[H]
	\caption{Communication Model}
	\centering
	\begin{multicols}{2}
		\input{"chapters/taxonomy/_table_taxo_Communication Model_p1.tex"}

		\input{"chapters/taxonomy/_table_taxo_Communication Model_p2.tex"}
	\end{multicols}
\end{table}

\subsubsection{Fault Tolerance}
Whether fault tolerance is supported.
\begin{table}[H]
	\caption{Fault Tolerance}
	\centering
	\begin{multicols}{2}
		\input{"chapters/taxonomy/_table_taxo_Fault Tolerance_p1.tex"}

		\input{"chapters/taxonomy/_table_taxo_Fault Tolerance_p2.tex"}
	\end{multicols}
\end{table}

\subsubsection{Implementation Type}
This describes how the programming model API is addressed.
It can be done through a \textit{library}, a \textit{language extension} or a \textit{language}.
\begin{table}[H]
	\caption{Implementation Type}
	\centering
	\begin{multicols}{2}
		\input{"chapters/taxonomy/_table_taxo_Implementation Type_p1.tex"}

		\input{"chapters/taxonomy/_table_taxo_Implementation Type_p2.tex"}
	\end{multicols}
\end{table}

\subsubsection{Data Persistence}
Support for data persistence.
\begin{table}[H]
	\caption{Data Persistence}
	\centering
	\begin{multicols}{2}
		\input{"chapters/taxonomy/_table_taxo_Data Persistence_p1.tex"}

		\input{"chapters/taxonomy/_table_taxo_Data Persistence_p2.tex"}
	\end{multicols}
\end{table}

\subsubsection{Scheduler Location}
Whether the scheduler is \textit{centralized} or \textit{distributed}.
\begin{table}[H]
	\caption{Scheduler Location}
	\centering
	\begin{multicols}{2}
		\input{"chapters/taxonomy/_table_taxo_Scheduler Location_p1.tex"}

		\input{"chapters/taxonomy/_table_taxo_Scheduler Location_p2.tex"}
	\end{multicols}
\end{table}

%\subsubsection{}
%\begin{table}[H]
%	\caption{}
%	\centering
%	\input{"chapters/taxonomy/_table_taxo_.tex"}
%\end{table}


\subsection{Other ideas}
\subsubsection{Scheduling policy}
The scheduling policy is how the tasks are ordered during the execution of the task-based application.
The dependencies between the tasks are respected by the scheduler.
It can also be optimized to reduce the data migrations across the nodes and try to execute tasks on the node where the data are present.

\subsubsection{Dynamic workflow}
It represents the ability of the scheduler to adapt its policy during runtime depending on the results of the tasks.
For instance, stop the application when the convergence is attained.


\subsubsection{Multi-backend}
Is the programming paradigm able to use several backends ?
Is it possible to use code in other languages as tasks ?


%\subsection{Learnability}
%\subsection{Understandability}
%\subsection{Communicativeness}

\section{Taxonomy Summary}

\begin{table}[H]
	\caption{Taxonomy I}
	\centering
	\newcolumntype{M}[1]{>{\centering\arraybackslash}m{#1}}
	\input{chapters/taxonomy/_table_taxo_cat1.tex}
\end{table}

\begin{table}[H]
	\caption{Taxonomy II}
	\centering
	\newcolumntype{M}[1]{>{\centering\arraybackslash}m{#1}}
	\input{chapters/taxonomy/_table_taxo_cat2.tex}
\end{table}

\begin{table}[H]
	\caption{Taxonomy III}
	\centering
	\input{chapters/taxonomy/_table_taxo_cat3.tex}
\end{table}


\section{Language Properties Relevant for Task-Based Programming}

\section{Languages Extension}